# -*- coding: utf-8 -*-
"""22201898_Shahriar_A3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C1UQT4WDB8-aBcYvE7rDevPUQTm-pA_W

Task 01
"""

#Task 01
import sys

def calculateUtility(currGeneSeq, targetGeneSeq, weightList):
    utilityScore = 0
    maxLen = max(len(currGeneSeq), len(targetGeneSeq))
    i = 0
    while i < maxLen:
        geneChar = 0
        targetChar = 0
        weight = 1

        if i < len(currGeneSeq):
            geneChar = ord(currGeneSeq[i])

        if i < len(targetGeneSeq):
            targetChar = ord(targetGeneSeq[i])

        if i < len(weightList):
            weight = weightList[i]

        utilityScore += weight * abs(geneChar - targetChar)
        i += 1
    return -utilityScore #the highest value(least negative)


def minimax(currGeneSeq, availNucleotides, agentOne, targetGeneSeq, weightList, alpha, beta):
    if len(availNucleotides) == 0:
        return calculateUtility(currGeneSeq, targetGeneSeq, weightList), currGeneSeq

    idx = 0
    length = len(availNucleotides)

    if agentOne:
        bestScore = -sys.maxsize #Agent one wants the max utility, so very low starting value will make the chance better to take the real score
        bestSeq = ""
        while idx < length:
            newSeq = currGeneSeq + availNucleotides[idx]
            newPool = availNucleotides[:idx] + availNucleotides[idx+1:]
            score, resultSeq = minimax(newSeq, newPool, False, targetGeneSeq, weightList, alpha, beta)

            if score > bestScore:
                bestScore = score
                bestSeq = resultSeq

            if alpha < bestScore:
                alpha = bestScore

            if beta <= alpha:
                break

            idx += 1

        return bestScore, bestSeq

    else:
        worstScore = sys.maxsize
        worstSeq = ""
        while idx < length:
            newSeq = currGeneSeq + availNucleotides[idx]
            newPool = availNucleotides[:idx] + availNucleotides[idx+1:]
            score, resultSeq = minimax(newSeq, newPool, True, targetGeneSeq, weightList, alpha, beta)

            if score < worstScore:
                worstScore = score
                worstSeq = resultSeq

            if beta > worstScore:
                beta = worstScore

            if beta <= alpha:
                break

            idx += 1

        return worstScore, worstSeq

#-----------------Input My SID Manually----------------
inputPool = input().strip().split(',')
targetGeneSeq = input().strip()
studentID = list(map(int, input().strip().split()))

#-----------Input my SID in the code itself------------
# inputPool = input().strip().split(',')
# targetGeneSeq = input().strip()
# studentID = [2, 2, 2, 0, 1, 8, 9, 8]                        # My SID: 22201898


targetLength = len(targetGeneSeq)
weightList = studentID[-targetLength:]                     # it is extracting last N digits based on target length

#sloving by minimax
finalScore, finalGene = minimax("", inputPool, True, targetGeneSeq, weightList, -sys.maxsize, sys.maxsize)

print("Best gene sequence generated:", finalGene)
print("Utility score:", finalScore)

"""Task 02"""

#Task 02
import sys

#-----------Normal Utility------------

def calculateNormalUtility(currGeneSeq, targetGeneSeq, weightList):
    score = 0
    maxLen = max(len(currGeneSeq), len(targetGeneSeq))
    i = 0
    while i < maxLen:
        geneVal = 0
        targetVal = 0
        weight = 1

        if i < len(currGeneSeq):
            geneVal = ord(currGeneSeq[i])
        if i < len(targetGeneSeq):
            targetVal = ord(targetGeneSeq[i])
        if i < len(weightList):
            weight = weightList[i]

        score += weight * abs(geneVal - targetVal)
        i += 1
    return -score

#-----------Booster Utility------------
def calculateBoosterUtility(currGeneSeq, targetGeneSeq, weightList, boosterMultiplier, boosterStartIndex):
    score = 0
    maxLen = max(len(currGeneSeq), len(targetGeneSeq))
    i = 0
    while i < maxLen:
        geneVal = 0
        targetVal = 0
        weight = 1

        if i < len(currGeneSeq):
            geneVal = ord(currGeneSeq[i])
        if i < len(targetGeneSeq):
            targetVal = ord(targetGeneSeq[i])
        if i < len(weightList):
            weight = weightList[i]

        if i >= boosterStartIndex:
            weight *= boosterMultiplier

        score += weight * abs(geneVal - targetVal)
        i += 1
    return -round(score, 2)

#Minimax with Booster Logic

def minimax(currGeneSeq, availNucleotides, agentOne, targetGeneSeq, weightList, alpha, beta, boosterMultiplier, boosterUsed, boosterStartIndex):

    if not availNucleotides:
        if boosterUsed:
            return calculateBoosterUtility(currGeneSeq, targetGeneSeq, weightList, boosterMultiplier, boosterStartIndex), currGeneSeq
        else:
            return calculateNormalUtility(currGeneSeq, targetGeneSeq, weightList), currGeneSeq

    if agentOne:
        maxScore = -sys.maxsize
        bestSeq = ""
        i = 0
        while i < len(availNucleotides):
            picked = availNucleotides[i]
            nextSeq = currGeneSeq + picked
            newPool = availNucleotides[:i] + availNucleotides[i+1:]

            useBooster = boosterUsed
            boostStart = boosterStartIndex
            if picked == 'S' and not boosterUsed:
                useBooster = True
                boostStart = len(currGeneSeq)

            score, resultSeq = minimax(nextSeq, newPool, False, targetGeneSeq, weightList, alpha, beta,
                                       boosterMultiplier, useBooster, boostStart)

            if score > maxScore:
                maxScore = score
                bestSeq = resultSeq

            if alpha < maxScore:
                alpha = maxScore

            if beta <= alpha:
                break
            i += 1
        return maxScore, bestSeq

    else:
        minScore = sys.maxsize
        bestSeq = ""
        i = 0
        while i < len(availNucleotides):
            picked = availNucleotides[i]
            nextSeq = currGeneSeq + picked
            newPool = availNucleotides[:i] + availNucleotides[i+1:]

            score, resultSeq = minimax(nextSeq, newPool, True, targetGeneSeq, weightList, alpha, beta, boosterMultiplier, boosterUsed, boosterStartIndex)

            if score < minScore:
                minScore = score
                bestSeq = resultSeq

            if beta > minScore:
                beta = minScore

            if beta <= alpha:
                break
            i += 1
        return minScore, bestSeq

#-----------------Input My SID Manually----------------
inputPool = input().strip().split(',')
targetGeneSeq = input().strip()
studentID = list(map(int, input().strip().split()))

#Directly Taking SID
# studentID = [2, 2, 2, 0, 1, 8, 9, 8]
boosterMultiplier = int(str(studentID[0]) + str(studentID[1])) / 100  # 22 â†’ 0.22


targetLength = len(targetGeneSeq)
weightList = studentID[-targetLength:]

#Run without booster(exclude S)
poolWithoutS = [i for i in inputPool if i != 'S']
scoreWithoutBooster, geneWithoutBooster = minimax("", poolWithoutS, True, targetGeneSeq, weightList, -sys.maxsize, sys.maxsize, boosterMultiplier, False, 0)

#Run with booster (include S)
poolWithS = inputPool.copy()
if 'S' not in poolWithS:
    poolWithS.append('S')

scoreWithBooster, geneWithBooster = minimax("", poolWithS, True, targetGeneSeq, weightList, -sys.maxsize, sys.maxsize, boosterMultiplier, False, 0)

#Output Logic
if scoreWithBooster > scoreWithoutBooster:
    print("YES")
else:
    print("NO")
print("With special nucleotide")
print("Best gene sequence generated:", geneWithBooster)
print("Utility score:", round(scoreWithBooster, 2))