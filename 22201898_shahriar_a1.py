# -*- coding: utf-8 -*-
"""22201898_Shahriar_A1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yNY2626z1OZgGQsblrB9dJ9NoZ0S4hGE

Assignment01 Part1
"""

#Writing Input and Output file

inputFile = open("inputPart1.txt", "w")
outputFile = open("outputPart1.txt", "w")


inputFile.close()
outputFile.close()

import heapq     #A* search algorithm follows priority queue data structure

def heuristicFunction(currNode, goalNode):
  x1, y1 = currNode
  x2, y2 = goalNode
  heuristicValue = abs(x1-x2) + abs(y1-y2)     #from the Manhattan distance
  return heuristicValue
def aStarSearch():
  inputFile = open("inputPart1.txt", "r")
  outputFile = open("outputPart1.txt", "w")
  m, n = map(int, inputFile.readline().split())   #Reading inputs
  startNode = tuple(map(int, inputFile.readline().split()))
  goalNode = tuple(map(int, inputFile.readline().split()))
  path = []
  for i in range(m):
    path.append(inputFile.readline().strip())
  inputFile.close()   #Done Reading
  possiblePositions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
  moveLetters = {(0,1): "R", (0,-1): "L", (1,0): "D", (-1,0): "U"}
  visited = set()
  startToAnyNode = {startNode: 0}  #g(n)
  startToGoalNode = {startNode: heuristicFunction(startNode, goalNode)}  #f(n) = g(n) + h(n)
  priorityQueue = [(startToGoalNode[startNode], 0, startNode, "")] #f(n), g(n), node, path
  heapq.heapify(priorityQueue)
  while priorityQueue:
    fn, gn, currNode, currPath = heapq.heappop(priorityQueue)
    if currNode == goalNode:
      outputFile.write(str(gn) + "\n")
      outputFile.write(currPath + "\n")
      outputFile.close()
      return
    if currNode in visited:
      continue
    visited.add(currNode)
    for dx, dy in possiblePositions:
      newX = currNode[0] + dx
      newY = currNode[1] + dy
      newPosition = (newX, newY)
      if 0 <= newX < m and 0 <= newY < n and path[newX][newY] == "0":
        newPath = currPath + moveLetters[(dx, dy)]
        newGn = gn + 1
        newFn = newGn + heuristicFunction(newPosition, goalNode)
        if newPosition not in startToAnyNode or newGn < startToAnyNode[newPosition]:
          startToAnyNode[newPosition] = newGn
          startToGoalNode[newPosition] = newFn
          heapq.heappush(priorityQueue, (newFn, newGn, newPosition, newPath))
  outputFile.write("-1")
  outputFile.close()
aStarSearch()

"""Assignment01 Part2"""

#Writing Input and Output file

inputFile = open("inputPart2.txt", "w")
outputFile = open("outputPart2.txt", "w")


inputFile.close()
outputFile.close()

from collections import defaultdict, deque
def checkAdmissibility():
 inputFile = open("inputPart2.txt", "r")
 outputFile = open("outputPart2.txt", "w")
 m, n = map(int, inputFile.readline().split())   #Reading inputs
 startNode, goalNode = map(int, inputFile.readline().split())
 heuristics = {}
 i = 0
 while i < m:
  node, hval = map(int, inputFile.readline().split())
  heuristics[node] = hval
  i = i + 1
 graph = defaultdict(list)
 j = 0
 while j < n:
  u, v = map(int, inputFile.readline().split())
  graph[u].append(v)
  graph[v].append(u)
  j = j + 1
 inputFile.close()
 distance = {}
 visited = set()
 queue = deque()
 queue.append((goalNode, 0))
 while queue:
  currNode, currDist = queue.popleft()
  if currNode in distance:
    continue
  else:
    visited.add(currNode)
    distance[currNode] = currDist
  for nearestNode in graph[currNode]:
      if nearestNode not in distance:
         queue.append((nearestNode, currDist + 1))
 inadmissibleNodes = []
 for node in heuristics:
    if node not in distance or heuristics[node] > distance[node]:
            inadmissibleNodes.append(node)
 if inadmissibleNodes:
        outputFile.write("0\n")
        outputFile.write("Inadmissible nodes: " + ' '.join(map(str, inadmissibleNodes)) + "\n")
 else:
        outputFile.write("1\n")
 outputFile.close()

checkAdmissibility()