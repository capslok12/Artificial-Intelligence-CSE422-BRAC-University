# -*- coding: utf-8 -*-
"""22201898_Shahriar_A2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uMrFoPR6YKV04F67EExpC_YuNaBLyl5Q

Assignment 02
Task 01
"""

import random
import math
import copy

#Component sizes: (width, height)
components = {
    "ALU": (5, 5),
    "Cache": (7, 4),
    "Control Unit": (4, 4),
    "Register File": (6, 6),
    "Decoder": (5, 3),
    "Floating Unit": (5, 5)
}

componentNames = list(components.keys())
gridSize = 25

#Interconnections (Register File(Index 3) ---> ALU(Index 0) and so on)
connections = [(3, 0), (2, 0), (0, 1), (3, 5), (1, 4), (4, 5)]

#Fitness weights
alpha = 1000  #Overlap penalty
beta = 2      #Wire length penalty
gamma = 1     #Bounding area penalty

#-------------------- Utility Functions --------------------

def generateChromosomes():
    return [(random.randint(0, gridSize), random.randint(0, gridSize)) for i in range(6)]

def euclideanDistance(a, b, aSize, bSize):
    aWidth, aHeight = aSize
    bWidth, bHeight = bSize

    axCenter = a[0] + aWidth / 2
    ayCenter = a[1] + aHeight / 2

    bxCenter = b[0] + bWidth / 2
    byCenter = b[1] + bHeight / 2

    dx = axCenter - bxCenter
    dy = ayCenter - byCenter

    distance = math.sqrt(dx**2 + dy**2)
    return distance

def overlaps(placement):
    overlaps = 0
    i = 0
    while i < len(placement):
        j = i + 1
        while j < len(placement):
            x1, y1 = placement[i]
            w1, h1 = components[componentNames[i]]
            x2, y2 = placement[j]
            w2, h2 = components[componentNames[j]]

            if not (x1 + w1 <= x2 or x2 + w2 <= x1 or
                    y1 + h1 <= y2 or y2 + h2 <= y1):
                overlaps += 1
            j += 1
        i += 1
    return overlaps

def totalWiring(placement):
    total = 0
    for i, j in connections:
        total = total + euclideanDistance(
            placement[i], placement[j],
            components[componentNames[i]], components[componentNames[j]]
        )
    return total

def boundingArea(placement):
    xs = [x for x, y in placement]
    ys = [y for x, y in placement]
    ws = [components[componentNames[i]][0] for i in range(6)]
    hs = [components[componentNames[i]][1] for i in range(6)]
    xMin, xMax = min(xs), max(xs[i] + ws[i] for i in range(6))
    yMin, yMax = min(ys), max(ys[i] + hs[i] for i in range(6))
    return (xMax - xMin) * (yMax - yMin)

#-------------------- GA Mechanics --------------------

def fitness(placement):
    overlap = overlaps(placement)
    wire = totalWiring(placement)
    area = boundingArea(placement)
    return - (alpha * overlap + beta * wire + gamma * area)

def singlePointCrossover(p1, p2):
    point = random.randint(1, 5)
    return p1[:point] + p2[point:], p2[:point] + p1[point:]

def mutate(chromosome, mutation_rate = 0.1):
    if random.random() < mutation_rate:
        i = random.randint(0, 5)
        chromosome[i] = (random.randint(0, gridSize), random.randint(0, gridSize))

#----------------- Main GA Loop --------------------

def geneticAlgorithm(generations = 15, popSize = 6):
    population = [generateChromosomes() for i in range(popSize)]

    gen = 0
    while gen < generations:
        population.sort(key = fitness, reverse = True)
        newPopulation = population[:2]

        numNeeded = popSize - len(newPopulation)
        for i in range(numNeeded // 2):
            p1, p2 = random.sample(population, 2)
            child1, child2 = singlePointCrossover(copy.deepcopy(p1), copy.deepcopy(p2))
            mutate(child1)
            mutate(child2)
            newPopulation.extend([child1, child2])

        if len(newPopulation) < popSize:
            p1, p2 = random.sample(population, 2)
            child, i = singlePointCrossover(copy.deepcopy(p1), copy.deepcopy(p2))
            mutate(child)
            newPopulation.append(child)

        population = newPopulation[:popSize]
        gen += 1

    best = max(population, key = fitness)
    print("Best Fitness:", fitness(best))
    print("Wiring Length:", totalWiring(best))
    print("Bounding Area:", boundingArea(best))
    print("Overlap Count:", overlaps(best))
    print("Best Placement:", best)
    return best


print("Running Task 1 (Single-Point Crossover)...")
geneticAlgorithm()

"""Assignment 02 Task 02"""

def twoPointCrossover(p1, p2):
    pt1, pt2 = sorted(random.sample(range(6), 2))
    child1 = p1[:pt1] + p2[pt1:pt2] + p1[pt2:]
    child2 = p2[:pt1] + p1[pt1:pt2] + p2[pt2:]
    return child1, child2

def geneticAlgorithmTwoPoint(generations = 15, popSize = 6):
    population = [generateChromosomes() for i in range(popSize)]

    gen = 0
    while gen < generations:
        population.sort(key = fitness, reverse = True)
        newPopulation = population[:2]  #taking best 2 chromosomes

        numNeeded = popSize - len(newPopulation)

        for i in range(numNeeded // 2):  #add 2 children each iteration
            p1, p2 = random.sample(population, 2)
            child1, child2 = twoPointCrossover(copy.deepcopy(p1), copy.deepcopy(p2))
            mutate(child1)
            mutate(child2)
            newPopulation.extend([child1, child2])

        population = newPopulation
        gen += 1


    best = max(population, key = fitness)
    print("Best Fitness (Two-Point):", fitness(best))
    print("Wiring Length:", totalWiring(best))
    print("Bounding Area:", boundingArea(best))
    print("Overlap Count:", overlaps(best))
    print("Best Placement:", best)
    return best
print("Running Task 2 (Two-Point Crossover)...")
geneticAlgorithm()